### 操作系统
<details>
    <summary>进程和线程的区别</summary>
    <ul>
        <li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li>
        <li>进程有自己独立的地址空间，每启动一个进程，系统将为其分配地址空间，建立数据表来维护代码段，堆栈段和数据段。
            <ul>
                <li>而线程是共享进程中的数据，使用相同的地址空间，CPU开销小。</li>
            </ul>
        </li>
        <li>线程之间的通信更方便，同一进程下的线程共享全局变量，静态变量等数据，进程之间的通信则需要以通信的方式进行。</li>
        <li>多进程比多线程更健壮，多线程中一个线程死亡意味着进程的死亡。而多进程程序不同进程之间互不影响。</li>
    </ul>
</details>

<details>
    <summary>进程间的通信方式（IPC）</summary>
    <ul>
        <li><strong>管道</strong>：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利。
            <ul>
                <li>匿名管道：用于亲缘关系进程，父子进程。</li>
                <li>有名管道：可用于无亲缘关系的进程间。</li>
            </ul>
        </li>
        <li><strong>信号</strong>：在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1。
            <ul>
                <li>PV操作用于同一进程实现互斥。</li>
                <li>PV操作用于不同进程实现同步。</li>
            </ul>
        </li>
        <li><strong>消息队列</strong>：在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。<br>
            <em><strong>消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。</strong></em>
            <ul>
                <li>不足：消息长度有上限</li>
            </ul>
        </li>
        <li><strong>共享内容</strong>：将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。
            <ul>
                <li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。</li>
                <li>不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。</li>
                <li>共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。</li>
                <li>生命周期随内核。</li>
            </ul>
        </li>
    </ul>
</details>
<details>
    <summary>进程的状态和转换关系</summary>
    <p><img src="image/image01.jpg" alt=""></p>
    <ol>
        <li>
            <p>就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
        </li>
        <li>
            <p>执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态。如：</p>
            <ul>
                <li>进程提出输入/输出请求而变成等待外部设备传输信息的状态</li>
                <li>进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态</li>
                <li>进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等</li>
            </ul>
        </li>
        <li>
            <p>阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如：</p>
            <ul>
                <li>输入/输出完成</li>
                <li>资源得到满足或错误处理完毕时</li>
            </ul>
            <p>处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
        </li>
        <li>
            <p>执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
        </li>
    </ol>
</details>
<details>
    <summary>死锁（死锁条件、避免死锁、死锁检测、死锁预防）</summary>
    <p><strong>死锁的定义：</strong><br>
        多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。</p>
    <p><strong>产生死锁的四大必要条件：</strong></p>
    <ol>
        <li>
            <p>资源互斥/资源不共享<br>
                每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用。</p>
        </li>
        <li>
            <p>占有和等待/请求并保持<br>
                已经得到资源的进程还能继续请求新的资源，所以个人觉得叫占有并请求也许更好理解。</p>
        </li>
        <li>
            <p>资源不可剥夺<br>
                当一个资源分配给了一个进程后，其它需要该资源的进程不ß能强制性获得该资源，除非该资源的当前占有者显示地释放该资源。</p>
        </li>
        <li>
            <p>环路等待<br>
                死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源。</p>
        </li>
    </ol>
    <p><strong>防止死锁的方法：</strong></p>
    <ol>
        <li>
            <p>破坏互斥条件</p>
            <ul>
                <li>方法：如果允许系统资源都能共享使用，则系统不会进入死锁状态。</li>
                <li>缺点：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</li>
            </ul>
        </li>
        <li>
            <p>破坏请求并保持条件</p>
            <ul>
                <li>方法：釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。
                </li>
                <li>缺点：系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
                </li>
            </ul>
        </li>
        <li>
            <p>破坏不可剥夺条件</p>
            <ul>
                <li>方法：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。
                </li>
                <li>缺点：该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
                </li>
            </ul>
        </li>
        <li>
            <p>破坏循环等待条件</p>
            <ul>
                <li>方法：为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。
                </li>
                <li>缺点：这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。
                </li>
            </ul>
        </li>
    </ol>
    <p><strong>死锁的检测方式</strong><br>
        绘制资源分配图，进行简化。</p>
    <blockquote>
        <p>死锁定理：</p>
        <ol>
            <li>如果资源分配图中没有环路，则系统没有死锁。</li>
            <li>如果资源分配图中出现了环路，则系统可能有死锁。</li>
            <li>如果资源分配图不可完全简化，则系统死锁。</li>
        </ol>
    </blockquote>
</details>