### 操作系统
<details>
    <summary>进程和线程的区别</summary>
    <ul>
        <li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）</li>
        <li>进程有自己独立的地址空间，每启动一个进程，系统将为其分配地址空间，建立数据表来维护代码段，堆栈段和数据段。
            <ul>
                <li>而线程是共享进程中的数据，使用相同的地址空间，CPU开销小。</li>
            </ul>
        </li>
        <li>线程之间的通信更方便，同一进程下的线程共享全局变量，静态变量等数据，进程之间的通信则需要以通信的方式进行。</li>
        <li>多进程比多线程更健壮，多线程中一个线程死亡意味着进程的死亡。而多进程程序不同进程之间互不影响。</li>
    </ul>
</details>

<details>
    <summary>进程间的通信方式（IPC）</summary>
    <ul>
        <li><strong>管道</strong>：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利。
            <ul>
                <li>匿名管道：用于亲缘关系进程，父子进程。</li>
                <li>有名管道：可用于无亲缘关系的进程间。</li>
            </ul>
        </li>
        <li><strong>信号</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
        </li>
        <li><strong>信号量</strong>：在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1。
            <ul>
                <li>PV操作用于同一进程实现互斥。</li>
                <li>PV操作用于不同进程实现同步。</li>
            </ul>
        </li>
        <li><strong>消息队列</strong>：在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。<br>
            <em><strong>消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。</strong></em>
            <ul>
                <li>不足：消息长度有上限</li>
            </ul>
        </li>
        <li><strong>共享内容</strong>：将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。
            <ul>
                <li>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。</li>
                <li>不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。</li>
                <li>共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。</li>
                <li>生命周期随内核。</li>
            </ul>
        </li>
        <li><strong>套接字</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。主要用于客户端和服务端之间的进程通信。
        </li>
    </ul>
</details>

<details>
    <summary>线程间的通信方式</summary>
    <ol>
        <li><strong>锁机制</strong>：包括互斥锁、条件变量、读写锁
            <ul>
                <li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
                <li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
                <li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。<em><strong>条件变量始终与互斥锁一起使用。</strong></em></li>
            </ul>
        </li>
        <li><strong>信号量机制(Semaphore)</strong>：包括无名线程信号量和命名线程信号量</li>
        <li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li>
    </ol>
    <p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
</details>

<details>
    <summary>进程的状态和转换关系</summary>
    <p><img src="image/image01.jpg" alt=""></p>
    <ol>
        <li>
            <p>就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p>
        </li>
        <li>
            <p>执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态。如：</p>
            <ul>
                <li>进程提出输入/输出请求而变成等待外部设备传输信息的状态</li>
                <li>进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态</li>
                <li>进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等</li>
            </ul>
        </li>
        <li>
            <p>阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如：</p>
            <ul>
                <li>输入/输出完成</li>
                <li>资源得到满足或错误处理完毕时</li>
            </ul>
            <p>处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p>
        </li>
        <li>
            <p>执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p>
        </li>
    </ol>
</details>

<details>
    <summary>进程调度算法和比较</summary>
    <p><img src="image/image03.png" alt=""></p>
    <ol>
        <li>
            <p><strong>先来先去服务(FCFS)</strong><br>
                先来先去服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。
            </p>
        </li>
        <li>
            <p><strong>时间片轮转法(RR)</strong><br>
                轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。
            </p>
            <ul>
                <li>过程：1、排成一个队列。2、每次调度时将CPU分派给队首进程。3、时间片结束时，发生时钟中断。4、暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前就绪的队首进程。</li>
                <li>说明：1、进程阻塞情况发生时，未用完时间片也要出让CPU。2、能够及时响应，但没有考虑作业长短等问题。3、系统的处理能力和系统的负载状态影响时间片长度。</li>
            </ul>
        </li>
        <li>
            <p><strong>最短进程优先(SJF)</strong><br>
                最短进程优先是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。
            </p>
        </li>
        <li>
            <p><strong>最短剩余时间优先(SRTF)</strong><br>
                最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。
            </p>
        </li>
        <li>
            <p><strong>高优先权优先调度算法HPF和高响应比优先调度算法HRRN</strong><br>
                （1）两种方式：非抢占式优先权算法、抢占式优先权算法（关键点：新作业产生时）<br>
                （2）类型:静态优先权：创建进程时确定，整个运行期间保持不变。动态优先权：创建进程时赋予的优先权可随进程的推进或随其等待时间的增加而改变。<br>
                （3）高响应比优先调度算法HRRN</p>
            <blockquote>
                <p>HRRN为每个作业引入动态优先权，使作业的优先级随着等待时间的增加而以速率a提高：优先权 =（等待时间+要求服务时间)/要求服务时间= 响应时间 / 要求服务时间。<br>
                    什么时候计算各进程的响应比优先权？（作业完成时、新作业产生时（抢占、非抢占）、时间片完成时、进程阻塞时）</p>
            </blockquote>
        </li>
        <li>
            <p><strong>多级反馈队列算法FB</strong></p>
            <ul>
                <li>过程：1、准备调度：先将它放入第一个队列的末尾，按FCFS原则排队等待调度。2、IF时间片内完成，便可准备撤离系统。3、IF时间片内未能完成，调度程序便将该进程转入第二队列的末尾等待再次被调度执行。4、当第一队列中的进程都执行完，系统再按FCFS原则调度第二队列。在第二队列的稍放长些的时间片内仍未完成，再依次将它放入第三队列。5、依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。
                </li>
                <li>说明:1、设置多个就绪队列，各队列有不同的优先级,优先级从第一个队列依次降低。2、赋予各队列进程执行时间片大小不同,
                    优先权越高，时间片越短。3、仅当优先权高的队列（如第一队列）空闲时，调度程序才调度第二队列中的进程运行。4、高优先级抢占时，被抢占的进程放回原就绪队列末尾。</li>
            </ul>
        </li>
    </ol>
</details>

<details>
    <summary>死锁（死锁条件、避免死锁、死锁检测、死锁预防）</summary>
    <p><strong>死锁的定义：</strong><br>
        多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。</p>
    <p><strong>产生死锁的四大必要条件：</strong></p>
    <ol>
        <li>
            <p>资源互斥/资源不共享<br>
                每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用。</p>
        </li>
        <li>
            <p>占有和等待/请求并保持<br>
                已经得到资源的进程还能继续请求新的资源，所以个人觉得叫占有并请求也许更好理解。</p>
        </li>
        <li>
            <p>资源不可剥夺<br>
                当一个资源分配给了一个进程后，其它需要该资源的进程不ß能强制性获得该资源，除非该资源的当前占有者显示地释放该资源。</p>
        </li>
        <li>
            <p>环路等待<br>
                死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源。</p>
        </li>
    </ol>
    <p><strong>防止死锁的方法：</strong></p>
    <ol>
        <li>
            <p>破坏互斥条件</p>
            <ul>
                <li>方法：如果允许系统资源都能共享使用，则系统不会进入死锁状态。</li>
                <li>缺点：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</li>
            </ul>
        </li>
        <li>
            <p>破坏请求并保持条件</p>
            <ul>
                <li>方法：釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。
                </li>
                <li>缺点：系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
                </li>
            </ul>
        </li>
        <li>
            <p>破坏不可剥夺条件</p>
            <ul>
                <li>方法：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。
                </li>
                <li>缺点：该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
                </li>
            </ul>
        </li>
        <li>
            <p>破坏循环等待条件</p>
            <ul>
                <li>方法：为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。
                </li>
                <li>缺点：这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。
                </li>
            </ul>
        </li>
    </ol>
    <p><strong>死锁的检测方式</strong><br>
        绘制资源分配图，进行简化。</p>
    <blockquote>
        <p>死锁定理：</p>
        <ol>
            <li>如果资源分配图中没有环路，则系统没有死锁。</li>
            <li>如果资源分配图中出现了环路，则系统可能有死锁。</li>
            <li>如果资源分配图不可完全简化，则系统死锁。</li>
        </ol>
    </blockquote>
    <p><strong>死锁的解除</strong></p>
    <ol>
        <li>资源剥夺法<br>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li>
        <li>撤销进程法<br>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
        <li>进程回退法<br>让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
    </ol>
</details>

### 计算机网络

<details>
    <summary>浏览器输入一个地址到看到返回内容中间发生了什么?</summary>
    <ol>
        <li>查询DNS，获取域名对应的IP。<br>
            <strong>DNS解析机制：</strong>
            <ol>
                <li>检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。</li>
                <li>如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。</li>
                <li>如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时：【如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。】【如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。】
                </li>
                <li>如果本地DNS服务器也失效：像广域的DNS服务器（13个跟解析服务器）进行查找。有【迭代】【递归】俩种方式。</li>
            </ol>
        </li>
        <li>客户机发送HTTP请求报文：
            <ol>
                <li>应用层：客户端发送HTTP请求报文</li>
                <li>传输层：切分长数据，并确保可靠性。</li>
                <li>网络层：进行路由</li>
                <li>数据链路层：传输数据</li>
                <li>物理层：物理传输bit</li>
            </ol>
        </li>
        <li>服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。</li>
        <li>客户端解析HTTP响应报文</li>
        <li>浏览器开始显示HTML</li>
        <li>浏览器重新发送请求获取图片、CSS、JS的数据。</li>
        <li>浏览器渲染页面<br>
            <strong>渲染机制：</strong><br>
            构建DOM树 -&gt; CSS解析 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制
            <ul>
                <li>构建DOM树<br>
                    当浏览器客户端从服务器那接受到HTML文档后，就会遍历文档节点然后生成DOM树，DOM树结构和HTML标签一一对应。需要注意记下几点：
                    <ul>
                        <li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。（这在后面会详细介绍。）</li>
                        <li>display:none 的元素也会在DOM树中。</li>
                        <li>注释也会在DOM树中</li>
                        <li>Script标签会在DOM树中</li>
                    </ul>
                </li>
                <li>CSS解析<br>
                    浏览器会解析CSS文件并生成CSS规则树，在过程中，每个CSS文件都会被分析成StyleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的选择器和声明对象以及其他对象。在这个过程需要注意的是：
                    <ul>
                        <li>CSS解析可以与DOM解析同进行。</li>
                        <li>CSS解析与script的执行互斥。</li>
                        <li>在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥。</li>
                    </ul>
                </li>
                <li>构建渲染树<br>
                    通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，让后对每个可见节点找到适配的CSS样式规则并应用。具体的规则有以下几点需要注意：
                    <ul>
                        <li>Render Tree和DOM Tree不完全对应。</li>
                        <li>display: none的元素不在Render Tree中</li>
                        <li>visibility: hidden的元素在Render Tree中</li>
                    </ul>
                </li>
                <li>渲染树布局<br>
                    布局阶段会从渲染树的更节点开始遍历，由于渲染树的每个节点都是一个Render
                    Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：
                    <ul>
                        <li>float元素，absoulte元素，fixed元素会发生位置偏移。</li>
                        <li>我们常说的脱离文档流，其实就是脱离Render Tree。</li>
                    </ul>
                </li>
                <li>渲染树绘制<br>
                    在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</li>
            </ul>
        </li>
    </ol>
</details>